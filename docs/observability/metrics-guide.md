# Observability Metrics Guide

## Overview

This guide covers all metrics exposed by the BIZRA platform for monitoring, alerting, and SLO tracking.

## Table of Contents

1. [HTTP Metrics](#http-metrics)
2. [Database Metrics](#database-metrics)
3. [Business Metrics](#business-metrics)
4. [System Metrics](#system-metrics)
5. [Custom Metrics](#custom-metrics)

## HTTP Metrics

### Request Duration

**Metric**: `http_request_duration_seconds`
**Type**: Histogram
**Labels**: `method`, `route`, `status_code`

Tracks the latency of HTTP requests in seconds.

**Buckets**: 0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10

**Queries**:

```promql
# p95 latency
histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[5m])) by (le, route))

# p99 latency
histogram_quantile(0.99, sum(rate(http_request_duration_seconds_bucket[5m])) by (le, route))
```

### Request Count

**Metric**: `http_requests_total`
**Type**: Counter
**Labels**: `method`, `route`, `status_code`

Total number of HTTP requests.

**Queries**:

```promql
# Request rate
sum(rate(http_requests_total[5m])) by (method, route)

# Error rate
sum(rate(http_requests_total{status_code=~"5.."}[5m])) / sum(rate(http_requests_total[5m]))
```

### Request/Response Size

**Metrics**: `http_request_size_bytes`, `http_response_size_bytes`
**Type**: Histogram
**Labels**: `method`, `route`, `status_code`

Track payload sizes for requests and responses.

### Active Connections

**Metric**: `http_active_connections`
**Type**: Gauge

Number of active HTTP connections.

## Database Metrics

### Query Duration

**Metric**: `db_query_duration_seconds`
**Type**: Histogram
**Labels**: `operation`, `table`, `status`

Database query execution time.

**Queries**:

```promql
# Slow queries (p95 > 1s)
histogram_quantile(0.95, sum(rate(db_query_duration_seconds_bucket[5m])) by (le, operation)) > 1
```

### Connection Pool

**Metric**: `db_pool_size`
**Type**: Gauge
**Labels**: `state` (active, idle)

Database connection pool statistics.

**Queries**:

```promql
# Pool utilization
db_pool_size{state="active"} / (db_pool_size{state="active"} + db_pool_size{state="idle"})
```

### Query Errors

**Metric**: `db_query_errors_total`
**Type**: Counter
**Labels**: `operation`, `table`, `error_type`

Total database query errors.

## Business Metrics

### User Registrations

**Metric**: `business_user_registrations_total`
**Type**: Counter
**Labels**: `source`, `tier`

Tracks user registration events.

**Queries**:

```promql
# Registration rate
sum(rate(business_user_registrations_total[1h])) by (tier)

# Daily registrations
sum(increase(business_user_registrations_total[24h]))
```

### Validation Metrics

**Metric**: `business_validation_requests_total`
**Type**: Counter
**Labels**: `validation_type`, `status`

Validation request count and status.

**Metric**: `business_validation_duration_seconds`
**Type**: Histogram
**Labels**: `validation_type`

Validation processing time.

### Active Users

**Metric**: `business_active_users`
**Type**: Gauge
**Labels**: `tier`

Currently active user count.

### Revenue Tracking

**Metric**: `business_revenue_total`
**Type**: Counter
**Labels**: `currency`, `tier`

Revenue generated by tier.

## System Metrics

### Memory Usage

**Metric**: `system_memory_usage_bytes`
**Type**: Gauge
**Labels**: `type` (heap_used, heap_total, rss, external)

Process memory consumption.

### CPU Usage

**Metric**: `system_cpu_usage_percent`
**Type**: Gauge

CPU usage percentage.

### Event Loop Lag

**Metric**: `system_event_loop_lag_seconds`
**Type**: Gauge

Node.js event loop lag.

### Cache Metrics

**Metrics**: `cache_hits_total`, `cache_misses_total`
**Type**: Counter
**Labels**: `cache_name`

Cache hit/miss tracking.

**Queries**:

```promql
# Cache hit rate
sum(rate(cache_hits_total[5m])) / (sum(rate(cache_hits_total[5m])) + sum(rate(cache_misses_total[5m])))
```

## SLO Metrics

### Availability

**Target**: 99.9% uptime

```promql
# 30-day availability
(sum(rate(http_requests_total{status_code!~"5.."}[30d])) / sum(rate(http_requests_total[30d]))) * 100
```

### Latency

**Targets**:

- p50 < 200ms
- p95 < 500ms
- p99 < 2000ms

```promql
# p95 latency check
histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[5m])) by (le)) < 0.5
```

### Error Budget

```promql
# Error budget remaining (%)
((1 - (sum(increase(http_requests_total{status_code=~"5.."}[30d])) / sum(increase(http_requests_total[30d])))) / (1 - 0.999)) * 100
```

## Alerting Thresholds

| Metric          | Warning | Critical |
| --------------- | ------- | -------- |
| p95 Latency     | > 1s    | > 5s     |
| Error Rate      | > 5%    | > 10%    |
| Pool Saturation | > 80%   | > 95%    |
| Memory Usage    | > 80%   | > 90%    |
| Error Budget    | < 10%   | < 0%     |

## Grafana Dashboards

1. **API Performance** (`/monitoring/grafana/dashboards/api-performance.json`)
   - Request rate, latency, error rate
   - Active connections, status codes
   - Request/response sizes

2. **Database Metrics** (`/monitoring/grafana/dashboards/database-metrics.json`)
   - Query latency, connection pool
   - Cache hit ratio, database size

3. **Business Metrics** (`/monitoring/grafana/dashboards/business-metrics.json`)
   - User activity, validation throughput
   - Revenue, subscriptions, conversion rates

4. **SLO Dashboard** (`/monitoring/grafana/dashboards/slo-dashboard.json`)
   - 30-day availability tracking
   - Error budget monitoring
   - Latency SLO compliance

## Best Practices

1. **Use rate() for counters**: Always use `rate()` or `increase()` with counter metrics
2. **Appropriate time windows**: Use 5m for real-time, 1h+ for trends
3. **Label cardinality**: Keep label values bounded to prevent metric explosion
4. **Histogram buckets**: Adjust buckets based on actual distribution
5. **Recording rules**: Pre-compute expensive queries for dashboards

## Custom Metrics

To add custom metrics:

```typescript
import { Counter, Histogram, Gauge } from "prom-client";

const myMetric = new Counter({
  name: "my_custom_metric_total",
  help: "Description of my metric",
  labelNames: ["label1", "label2"],
});

myMetric.inc({ label1: "value1", label2: "value2" });
```

## References

- [Prometheus Best Practices](https://prometheus.io/docs/practices/)
- [Grafana Dashboard Design](https://grafana.com/docs/grafana/latest/best-practices/)
- [SRE Book - Monitoring](https://sre.google/sre-book/monitoring-distributed-systems/)
